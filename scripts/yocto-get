#!/usr/bin/env python3
import argparse
import sys
import os
import subprocess
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parent))
from yocto_layer_index import LayerIndex, DEFAULT_BRANCH
try:
    from yocto_utils import run_command as utils_run_command, get_yocto_branch, UI
except ImportError as e:
    print(f"DEBUG: ImportError: {e}")
    def utils_run_command(cmd, cwd=None):
        subprocess.run(cmd, shell=True, check=True, cwd=cwd)
    def get_yocto_branch(root): return DEFAULT_BRANCH
    class UI:
        BOLD = CYAN = GREEN = RED = YELLOW = DIM = NC = ''
        @classmethod
        def print_header(cls, text): print(text)
        @classmethod
        def print_success(cls, text): print(text)
        @classmethod
        def print_warning(cls, text): print(text)
        @classmethod
        def print_error(cls, text, fatal=False): 
             print(f"Error: {text}")
             if fatal: sys.exit(1)
        @classmethod
        def print_item(cls, l, v): print(f"{l}: {v}")

WORKSPACE_ROOT = Path(__file__).resolve().parent.parent
SOURCES_DIR = WORKSPACE_ROOT / "yocto" / "sources"
BUILD_DIR = WORKSPACE_ROOT / "bitbake-builds" / "poky-master" / "build"

def run_command(cmd, cwd=None, capture=False):
    try:
        if capture:
            return subprocess.run(cmd, shell=True, check=True, capture_output=True, text=True, cwd=cwd).stdout.strip()
        else:
            subprocess.run(cmd, shell=True, check=True, cwd=cwd)
            return True
    except subprocess.CalledProcessError as e:
        if capture:
            return None
        UI.print_error(f"Command failed: {cmd}")
        return False

def get_active_layers():
    output = run_command("bitbake-layers show-layers", cwd=BUILD_DIR, capture=True)
    if not output:
        return []
    layers = []
    for line in output.splitlines():
        parts = line.split()
        if len(parts) >= 2 and parts[0] != "layer":
             if parts[0] in ["NOTE:", "WARNING:", "ERROR:"]:
                 continue
             layers.append(parts[0]) # name
    return layers


def ensure_layer_recursive(index, layer_name, vcs_url, subdir, branch, visited=None):
    if visited is None:
        visited = set()
    
    if layer_name in visited:
        return True
    visited.add(layer_name)

    # Special handling for openembedded-core which is usually 'meta' or 'core'
    if layer_name == "openembedded-core":
        active_layers = get_active_layers()
        if "meta" in active_layers or "core" in active_layers or "meta-poky" in active_layers:
            UI.print_success(f"Skipping '{layer_name}' (provided by core/meta/poky)")
            return True

    UI.print_item("Checking layer", layer_name)
    
    # 1. Check if layer is active
    active_layers = get_active_layers()
    if layer_name in active_layers:
        UI.print_success(f"Layer '{layer_name}' is already active")
        return True

    # 2. Get dependencies and ensure them first
    UI.print_item("Status", f"Resolving dependencies for '{layer_name}'...")
    
    layers_search = index.search_layers(layer_name)
    layer_item = None
    for l in layers_search:
        if l['name'] == layer_name:
            layer_item = l
            break
            
    if layer_item:
        deps = index.get_layer_dependencies(layer_item['id'])
        if deps:
            UI.print_item("Dependencies", ', '.join([d['name'] for d in deps]))
            for dep in deps:
                # Resolve details for dependency
                dep_lb = index.get_layerbranch(dep['id'])
                
                if dep_lb:
                    dep_vcs = dep_lb.get('vcs_url', dep.get('vcs_url'))
                    dep_subdir = dep_lb.get('vcs_subdir', '')
                    # Fix: Ensure we match truthfully or fallback
                    dep_branch = dep_lb.get('actual_branch') or branch 
                    
                    # Recursion
                    if not ensure_layer_recursive(index, dep['name'], dep_vcs, dep_subdir, dep_branch, visited):
                        return False
                else:
                    UI.print_warning(f"Could not resolve details for dependency '{dep['name']}'. Skipping.")
    else:
        UI.print_warning(f"Could not query layer details for '{layer_name}'. Dependencies might be missing.")

    # 3. Check if layer exists locally in sources/
    layer_path = SOURCES_DIR / layer_name
    if not layer_path.exists():
        UI.print_item("Action", f"Cloning '{layer_name}'...")
        SOURCES_DIR.mkdir(parents=True, exist_ok=True)
        
        repo_name = vcs_url.split('/')[-1].replace('.git', '')
        repo_path = SOURCES_DIR / repo_name
        
        if not repo_path.exists():
            print(f"  Cloning {repo_name} from {vcs_url} (branch: {branch})...")
            cmd = f"git clone -b {branch} {vcs_url} {repo_path}"
            if not run_command(cmd):
                UI.print_warning(f"Clone failed with branch '{branch}'. Trying 'master'...")
                cmd_master = f"git clone -b master {vcs_url} {repo_path}"
                if not run_command(cmd_master):
                    return False
        else:
             UI.print_item("Info", f"Repo '{repo_name}' exists, skipping clone.")
             
        if subdir:
             layer_path = repo_path / subdir
        else:
             layer_path = repo_path
             
    else:
         pass 

    # Re-eval layer path
    repo_name = vcs_url.split('/')[-1].replace('.git', '')
    repo_path = SOURCES_DIR / repo_name
    
    final_layer_path = repo_path
    if subdir:
        final_layer_path = repo_path / subdir
        
    # Check if we landed in a valid layer
    if not (final_layer_path / "conf" / "layer.conf").exists():
        # Heuristic: maybe valid info is just repo_path?
        if (repo_path / "conf" / "layer.conf").exists():
             final_layer_path = repo_path
        else:
             UI.print_warning(f"No layer.conf found at {final_layer_path}")

    UI.print_item("Registration", f"Syncing {final_layer_path.name}")
    
    cmd = f"bitbake-layers add-layer {final_layer_path.resolve()}"
    if run_command(cmd, cwd=BUILD_DIR):
        UI.print_success(f"Layer '{layer_name}' added successfully")
        return True
    return False

def add_to_image(recipe_name, image_name):
    """Placeholder or minimal implementation for add_to_image."""
    if not image_name:
        return
    UI.print_item("Adding to image", f"{recipe_name} -> {image_name}")
    # Logic to call add_package_to_image from yocto_utils would go here
    from yocto_utils import add_package_to_image
    if add_package_to_image(WORKSPACE_ROOT, image_name, recipe_name):
        UI.print_success(f"Updated {image_name}")
    else:
        UI.print_error(f"Failed to update {image_name}")

def main():
    default_branch = get_yocto_branch(WORKSPACE_ROOT)
    parser = argparse.ArgumentParser(description="Fetch and install recipes from OpenEmedded Layer Index")
    parser.add_argument("recipe", help="Recipe name to fetch")
    parser.add_argument("--image", help="Target image to add recipe to")
    parser.add_argument("--branch", default=default_branch, help=f"Yocto Branch (default: {default_branch})")
    args = parser.parse_args()

    UI.print_header("Yocto Recipe Installer")
    UI.print_item("Workspace Branch", default_branch)

    # 1. Search
    UI.print_item("Searching", f"'{args.recipe}' in branch '{args.branch}'...")
    index = LayerIndex(branch=args.branch)
    if not index.get_branch_id():
        UI.print_error(f"Invalid branch '{args.branch}'", fatal=True)
        
    recipes = index.search_recipes(args.recipe)
    
    exact_match = None
    for r in recipes:
        if r['pn'] == args.recipe:
            exact_match = r
            break
            
    candidate = None
    if exact_match:
        candidate = index.get_recipe_layer_info(exact_match)
    elif recipes:
        for r in recipes:
            info = index.get_recipe_layer_info(r)
            if info:
                candidate = info
                break
                
    if not candidate:
        UI.print_error(f"Recipe '{args.recipe}' not found in branch '{args.branch}'", fatal=True)
        
    UI.print_item("Found", f"{UI.GREEN}{candidate['recipe_name']}{UI.NC} (layer: {UI.CYAN}{candidate['layer_name']}{UI.NC})")
    
    # 2. Ensure Layer (Recursive)
    if not ensure_layer_recursive(index, candidate['layer_name'], candidate['layer_vcs_url'], candidate['vcs_subdir'], candidate.get('actual_branch', args.branch)):
        UI.print_error("Failed to configure layer", fatal=True)
        
    # 3. Add to Image
    if args.image:
        add_to_image(candidate['recipe_name'], args.image)
    
    print(f"\n  {UI.BOLD}{UI.GREEN}Setup complete!{UI.NC}")
    print(f"  Run {UI.CYAN}bitbake {args.image or 'falcon-image'}{UI.NC} to build.")

if __name__ == "__main__":
    main()

